<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터 실행하기</title>

    <link rel="stylesheet" href="https://webfontworld.github.io/gmarket/GmarketSans.css">
    <link rel="stylesheet" href="https://websfont.github.io/nanumSquareNeo/nanumSquareNeo.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="../assets/css/default.min.css">

</head>
<body>
    <div id="wrap">
        <header id="header">
            <h1><a href="index.html">javascript</a></h1>
            <nav>
                <ul>
                    <li><a href="javascript01.html">데이터 저장하기</a></li>
                    <li><a href="javascript02.html">데이터 불러오기</a></li>
                    <li class="active"><a href="javascript03.html">데이터 실행하기</a></li>
                    <li><a href="javascript04.html">데이터 제어하기</a></li>
                </ul>
                <ul>
                    <li><a href="javascript05.html">문자열 객체</a></li>
                    <li><a href="javascript06.html">배열 객체</a></li>
                    <li><a href="javascript07.html">수학 객체</a></li>
                    <li><a href="javascript08.html">브라우저 객체</a></li>
                    <li><a href="javascript09.html">요소 객체</a></li>
                    <li><a href="javascript10.html">이벤트 객체</a></li>
                </ul>
                <ul>
                    <li><a href="javascript11.html">데이터 효과</a></li>
                    <li><a href="javascript12.html">퀴즈 효과</a></li>
                    <li><a href="javascript13.html">마우스 효과</a></li>
                    <li><a href="javascript14.html">슬라이드 효과</a></li>
                </ul>
            </nav>
            </nav>
        </header>
        <!-- //header -->

        <main id="main">
            <div class="main__menu">
                <ul>
                    <li><a href="#sample01">01. 함수 : 선언적 함수</a></li>
                    <li><a href="#sample02">02. 함수 : 익명 함수</a></li>
                    <li><a href="#sample03">03. 함수 : 매개변수 함수</a></li>
                    <li><a href="#sample04">04. 함수 : 리턴값 함수</a></li>
                    <li><a href="#sample05">05. 함수 : 매개변수 + 리턴값 함수</a></li>
                    <li><a href="#sample06">06. 화살표 함수 : 선언적 함수</a></li>
                    <li><a href="#sample07">07. 화살표 함수 : 익명 함수</a></li>
                    <li><a href="#sample08">08. 화살표 함수 : 매개변수 함수</a></li>
                    <li><a href="#sample09">09. 화살표 함수 : 리턴값 함수</a></li>
                    <li><a href="#sample10">10. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값 함수</a></li>
                    <li><a href="#sample11">11. 함수 유형 : 함수와 매개변수를 이용한 형태</a></li>
                    <li><a href="#sample12">12. 함수 유형 : 함수와 변수를 이용한 형태</a></li>
                    <li><a href="#sample13">13. 함수 유형 : 함수와 배열 이용한 형태</a></li>
                    <li><a href="#sample14">14. 함수 유형 : 함수와 객체 이용한 형태</a></li>
                    <li><a href="#sample15">15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</a></li>
                    <li><a href="#sample16">16. 함수 유형 : 객체 안에 함수를 이용한 형태</a></li>
                    <li><a href="#sample17">17. 함수 유형 : 객체 생성자 함수</a></li>
                    <li><a href="#sample18">18. 함수 유형 : 프로토타입 함수</a></li>
                    <li><a href="#sample19">19. 함수 유형 : 객체 리터럴 함수</a></li>
                    <li><a href="#sample20">20. 함수 : 즉시실행 함수</a></li>
                    <li><a href="#sample21">21. 함수 : 파라미터 함수</a></li>
                    <li><a href="#sample22">22. 함수 : 재귀 함수</a></li>
                    <li><a href="#sample23">23. 함수 : 콜백 함수</a></li>
                    <li><a href="#sample24">24. 함수 : 비동기 함수 : 콜백 함수</a></li>
                    <li><a href="#sample25">25. 함수 : 비동기 함수 : 프로미스</a></li>
                    <li><a href="#sample26">26. 함수 : 비동기 함수 : async/await</a></li>
                    <li><a href="#sample27">27. 함수 : 중첩 함수</a></li>
                    <li><a href="#sample28">28. 함수 : 클로저</a></li>
                    <li><a href="#sample29">29. 클래스 : 기본</a></li>
                    <li><a href="#sample30">30. 클래스 : 상속</a></li>
                </ul>
            </div>
            <!-- //main__menu -->

            <div class="main__sample">
                <div id="sample01" class="sample">
                    <h3>01. 선언적 함수</h3>
                    <p>자바스크립트에서 함수(function)는 재사용 가능한 코드 블록입니다. 함수는 특정 작업을 수행하거나 값을 계산하는 데 사용됩니다.
                    함수는 코드의 구조를 더 모듈화하고 관리 가능하게 만들어주며, 코드를 논리적 단위로 분리하여 작성하고 유지보수할 수 있도록 도와줍니다.</p>
<pre><code class="language-js">{
    function func() {
        var x = 100;
        var y = 200;
        var z = "javascript";

        console.log(x);
        console.log(y);
        console.log(z);
    }
    func();

    function func1(){
        console.log("1. 실행되었습니다.");
    }
    func1();
}
</code></pre>
                    <p class="desc">선언적 함수는 function 키워드를 사용하여 정의된 함수입니다. 선언적 함수 주요 특징으로는 3가지가 있습니다.<br> 1. 정의와 호출 분리 - 함수의 정의와 호출을 명확하게 분리하여 함수를 먼저 정의 후 필요할 때 호출<br> 2. 가독성 향상 - 함수의 이름과 매개변수, 본문이 분리되어 코드의 가독성 향상<br> 3. 코드 모듈화 - 여러번 호출 할 수 있으며 중복되는 코드는 피하고 유지보수성을 높일 수 있음<br></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                200<br>
                                javescript<br>
                                1. 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>                
                <!-- //sample01 -->

                <div id="sample02" class="sample">
                    <h3>02. 익명 함수</h3>                        
                    <p>익명 함수(Anonymous Function)는 이름이 없는 함수를 의미합니다. 익명 함수는 주로 함수형 프로그래밍 언어나 다른 언어에서 함수를 값으로 다룰 수 있는 경우에 사용됩니다. 이 함수들은 일반적인 함수와 마찬가지로 입력을 받아서 어떠한 동작을 수행하고 결과를 반환할 수 있습니다.</p>
<pre><code class="language-js">{
    const func = function (){
        let x = 100;
        let y = 200;
        let z = "javascript";

        console.log(x);
        console.log(y); 
        console.log(z);
    }
    func();

    const func1 = function(){
        console.log("2. 실행되었습니다.");
    }
    func1();
}
</code></pre>
                    <p class="desc">익명 함수의 주요 특징으로는 4가지가 있습니다.<br> 1. 이름이 없음 - 이름이 없기 때문에 함수를 호출하거나 다루는 데 사용하는 변수나 매개변수에 할당되거나 직접 사용<br> 2. 간결성 - 익명 함수는 작은 단위의 동작을 간결하게 정의할 수 있음<br> 3. 일급함수 - 함수를 변수에 할당하거나 함수의 매개변수로 전달하고 반환값으로도 사용할 수 있다는 것을 의미<br> 4. 코드블록 전달 - 부 언어에서는 익명 함수를 다른 함수에 코드 블록으로 전달하는 데 사용</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                200<br>
                                javescript<br>
                                2. 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample02 -->

                <div id="sample03" class="sample">
                    <h3>03. 매개변수 함수</h3>                        
                    <p>매개변수 함수(Parameter Function)는 다른 함수의 인자로 전달되는 함수를 말합니다.</p>
<pre><code class="language-js">{
    function func (x, y, z){
        console.log(x);
        console.log(y);
        console.log(z);
    }
    func(100, 200, "javascript");
}
{
    const func1 = function (x, y, z){
        console.log(x);
        console.log(y);
        console.log(z);
    }
    func1(100, 200, "javascript");

    function func1(str){
        console.log(str);
    }
    func1("3. 실행되었습니다.");
}
</code></pre>
                    <p class="desc">매개변수 함수는 일급 함수(First-Class Function)의 특징을 활용하여 다른 함수의 인자로 넘길 수 있으며, 필요한 동작을 외부에서 정의하고 전달할 수 있습니다. 매개변수 함수를 사용하면 함수 간의 추상화와 모듈화를 촉진하고, 코드 재사용성을 높일 수 있습니다. 매개변수 함수의 주요 특징으로는 3가지가 있습니다.<br> 1. 일급 함수 - 프로그래밍 언어에서 매개변수 함수는 일급 함수로 취급 즉, 함수를 다른 함수의 인자로 전달하거나 반환값으로 사용<br> 2. 콜백 함수 - 다른 함수의 호출 시점에 실행되는 콜백 함수<br> 3. 모듈화와 추상화 - 함수의 동작을 외부에서 정의하고 전달할 수 있어 코드의 모듈화와 추상화가 쉬워짐</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                200<br>
                                javescript<br>
                                100<br>
                                200<br>
                                javescript<br>
                                3. 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample03 -->

                <div id="sample04" class="sample">
                    <h3>04. 리턴값 함수</h3>                        
                    <p>리턴값 함수(Return Value Function)는 함수가 실행된 후 결과 값을 반환하는 함수를 말합니다.</p>
<pre><code class="language-js">{
    function func (){
        const x = 100;
        const y = 200;
        const z = "javascript";
        return x + y;       //결과의 의미
    }
    console.log(func());
}
{
    const func1 = function (){
        let x = 100;
        let y = 200;
        let z = "javascript";
        return x + y;       //결과의 의미
    }
    console.log(func1());

    function func2(){
        return "4. 실행되었습니다.";
    }
    console.log(func2());
}
</code></pre>
                    <p class="desc">리턴값 함수는 입력 값을 받아서 어떤 작업을 수행한 후 결과 값을 반환할 수 있습니다. 주요 특징으로는 3가지가 있습니다.<br> 1. 결과 반환 - 함수의 본문 내에서 return 키워드를 사용하여 어떤 값을 반환할지 지정, 함수가 호출되면 이 값이 호출자에게 반환<br> 2. 함수 호출 후 사용 - 리턴값 함수는 호출된 이후에 반환값을 얻음, 이 값을 변수에 할당하거나 다른 함수의 인자로 전달 할 수 있음<br> 3. 다양한 반환 유형 - 단일 값 또는 객체, 배열 등 다양한 유형의 값을 반환</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                300<br>
                                300<br>
                                4. 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample04 -->

                <div id="sample05" class="sample">
                    <h3>05. 매개변수 + 리턴값 함수</h3>                        
                    <p>매개변수를 받는 함수와 반환값을 가지는 함수를 함께 사용하는 것은 자바스크립트에서 일반적으로 수행되는 작업입니다. 함수를 호출할 때 매개변수를 전달하여 함수 내에서 처리한 후 결과 값을 반환할 수 있습니다.</p>
<pre><code class="language-js">{
    function func(x){
        return x;
    };
    console.log(func(100));

    const func1 = function(x){
        return x;
    };
    console.log(func1(100));

    function func2(str){
        return str;
    }
    console.log(func2("5. 실행되었습니다."));
}
</code></pre>
                    <p class="desc">함수는 코드 내에서 작업을 수행하고 결과를 반환하기 위해 사용되며, 함수 선언식과 함수 표현식은 그 방식을 다르게 표현하는 방법 중 두 가지입니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                100<br>
                                100<br>
                                5. 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample05 -->
                
                <div id="sample06" class="sample">
                    <h3>06. 화살표 함수 : 선언적 함수</h3>                        
                    <p>화살표 함수는 함수를 간결하게 작성할 수 있도록 도와줍니다. 선언적 함수를 화살표 함수를 사용해서 출력할 수 있습니다. 일반 함수 선언보다 간결하고 명확한 문법을 가지고 있어서 주로 콜백 함수나 간단한 함수 표현식에 사용됩니다.</p>
<pre><code class="language-js">{
    func = () => {
        document.write("함수가 실행되었습니다.");
    }
    func();

    func1 = () => {
        var x = 100;
        var y = 200;
        var z = "javascript";

        console.log(x);
        console.log(y);
        console.log(z);
    }
    func1();

    func2 = () => {
        console.log("6. 실행되었습니다.");
    }
    func2();
}
</code></pre>
                    <p class="desc"> 선언적 함수는 function 키워드를 사용하여 선언되며, 화살표 함수는 () => 구문을 사용하여 표현됩니다. </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                함수가 실행되었습니다.<br>
                                100<br>
                                200<br>
                                javascript<br>
                                6. 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample06 -->

                <div id="sample07" class="sample">
                    <h3>07. 화살표 함수 : 익명 함수</h3>                        
                    <p>익명 함수(anonymous function)를 화살표 함수로 표현하는 방식은 함수의 이름을 생략하고 직접 함수를 정의하는 것을 의미합니다</p>
<pre><code class="language-js">{
    const func = () => {
        document.write("함수가 실행되었습니다.");
    }
    func();

    const func1 = () => {
        let x = 100;
        let y = 200;
        let z = "javascript";

        console.log(x);
        console.log(y); 
        console.log(z);
    }
    func1();        

    const func2 = () => {
        console.log("7. 실행되었습니다.");
    }
    func2();
}
</code></pre>
                    <p class="desc">화살표 함수의 간결한 문법을 활용하여 익명 함수를 표현할 수 있습니다. </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                함수가 실행되었습니다.<br>
                                100<br>
                                200<br>
                                javascript<br>
                                7. 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample07 -->

                <div id="sample08" class="sample">
                    <h3>08. 화살표 함수 : 매개변수 함수</h3>                        
                    <p>매개변수를 가지는 함수를 화살표 함수로 표현하는 방식으로 표현할 수 있습니다.</p>
<pre><code class="language-js">{
    func = (x) => {
        document.write(x);
    }
    func("함수가 실행되었습니다.");

    func1 = (x, y, z) => {
        console.log(x);
        console.log(y);
        console.log(z);
    }
    func1(100, 200, "javascript");
}
{
    const func2 = (x, y, z) => {
        console.log(x);
        console.log(y);
        console.log(z);
    }
    func2(100, 200, "javascript");

    func3 = (str) => {
        console.log(str);
    }
    func3("8. 실행되었습니다.");
}
</code></pre>
                    <p class="desc">여러 개의 매개변수를 가진 함수의 경우에도 동일한 방식으로 표현할 수 있습니다. 매개변수들을 소괄호 ()로 감싸고, 화살표 => 뒤에 함수 본문을 작성하면 됩니다. </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                함수가 실행되었습니다.<br>
                                100<br>
                                200<br>
                                javescript<br>
                                100<br>
                                200<br>
                                javescript<br>
                                8. 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample08 -->

                <div id="sample09" class="sample">
                    <h3>09. 화살표 함수 : 리턴값 함수</h3>                        
                    <p>리턴값을 가지는 함수를 화살표 함수로 표현하는 방식으로 표현할 수 있습니다.</p>
<pre><code class="language-js">{
    func = () => {
        const x = "함수가 실행되었습니다."
        return x;
    }
    document.write(func());

    func1 = () => {
        const x = 100;
        const y = 200;
        const z = "javascript";
        return x + y;       
    }
    console.log(func1());
}
{
    const func2 = () => {
        let x = 100;
        let y = 200;
        let z = "javascript";
        return x + y;       
    }
    console.log(func2());

    func3 = () => {
        return "9. 실행되었습니다.";
    }
    console.log(func3());
}
</code></pre>
                    <p class="desc">리턴값을 계산하는 부분을 화살표 => 뒤에 중괄호 {}로 리턴문을 묶고, 필요한 값을 리턴해주면 됩니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                함수가 실행되었습니다.<br>
                                300<br>
                                300<br>
                                9. 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample09 -->

                <div id="sample10" class="sample">
                    <h3>10. 화살표 함수 : 믹명 함수 + 매개변수 + 리턴값 함수</h3>                        
                    <p>매개변수와 리턴문을 가진 경우에도 간결하게 표현할 수 있으며, 화살표 함수의 간결한 문법을 활용하여 코드를 더 읽기 쉽게 만들 수 있습니다.</p>
<pre><code class="language-js">{

    //익명 함수
    const func = (x) => {
        return x;
    }
    console.log(func("10. 함수가 실행되었습니다.1"));

    const func1 = (str) => {
        return str;
    }
    console.log(func1("실행되었습니다."));
    
    //매개변수 한개일때 괄호 생략 가능
    const func3 = x => {
        return x;
    }
    console.log(func3("10. 함수가 실행되었습니다.2"));

    const func4 = str => {
        return str;
    }
    console.log(func4("실행되었습니다."));

    //리턴 생략
    const func5 = x => x;
    
    console.log(func5("10. 함수가 실행되었습니다.3"));

    const func6 = str => str;

    console.log(func6("실행되었습니다."));

    //선언적 함수 (가독성X)
    func7 = x => x;
    
    console.log(func7("10. 함수가 실행되었습니다.7"));

    func8 = str => str;
            
    console.log(func8("실행되었습니다."));
}
</code></pre>
                    <p class="desc">익명 함수가 매개 변수와 리턴문을 가진 경우에 매개 변수가 한개 일 경우에는 괄호를 생략 할 수 있으며 리턴문도 한 개일 경우에 {}와 리턴이라는 문구를 생략 가능합니다. 익명 함수를 선언적 함수처럼 const 키워드를 생략하여 표현 할 수 있지만 가독성이 떨어집니다.</p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                10. 함수가 실행되었습니다.1<br>
                                실행되었습니다.<br>
                                10. 함수가 실행되었습니다.2<br>
                                실행되었습니다.<br>
                                10. 함수가 실행되었습니다.3<br>
                                실행되었습니다.<br>
                                10. 함수가 실행되었습니다.4<br>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample10 -->

                <div id="sample11" class="sample">
                    <h3>11. 함수 유형 : 함수와 매개변수를 이용한 형태</h3>                        
                    <p>함수와 매개변수를 이용하여 표현할 수 있습니다.</p>
<pre><code class="language-js">{
    function func(num, str){
        console.log(`${num}. ${str}`); 
    };
    func(11, "함수가 실행되었습니다.");
}
</code></pre>
                    <p class="desc">
                        위의 예제는 매개변수를 이용하여 func를 정의한 내용입니다.<br>
                        ``(탬플릿 리터럴)은 문자열을 정의할 때 보간을 할 수 있게 해주는 문자열 리터럴의 확장형태입니다.<br>
                        템플릿 리터럴은 ``를 사용하여 문자열을 정의하고 ${}은 문자열내에서 표현식을 삽입하고 변수를 보간하는데 사용합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        function func(num, str){
                                            document.write(`${num}. ${str}`); 
                                        };
                                        func(11, "함수가 실행되었습니다.");
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample11 -->

                <div id="sample12" class="sample">
                    <h3>12. 함수 유형 : 함수와 변수를 이용한 형태</h3>                        
                    <p>변수, 함수 정의, 탬플릿 리터럴을 이용하여 사용할 수 있습니다.</p>
<pre><code class="language-js">{
    const num = 12;
    const str = "함수가 실행되었습니다.";

    function func(num, str){
        console.log(num + ". " + str);
        console.log(`${num}. ${str}`); 
    };
    func(num, str);
}
</code></pre>
                    <p class="desc">
                        위에 예제는 두가지 방법을 사용하여 문자열을 출력한 방법입니다.<br>
                        첫 번째 방식은 문자열 연결 연산자(+)를 사용하여 생성합니다.<br>
                        두 번째 방식은 템플릿 리터럴을 사용하여 생성합니다
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        const num = 12;
                                        const str = "함수가 실행되었습니다.";

                                        function func(num, str){
                                            document.write(num + ". " + str);
                                            document.write("<br>");
                                            document.write(`${num}. ${str}`);  //탬플릿 리터럴을 사용하여 표현한 방식(새로생긴 명령어로 ``안에 그대로 쓰면됨)
                                        };
                                        func(num, str);
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample12 -->

                <div id="sample13" class="sample">
                    <h3>13. 함수 유형 : 함수와 배열 이용한 형태</h3>                        
                    <p>배열 사용하여 함수를 여러번 호출할 수 있습니다.</p>
<pre><code class="language-js">{
    const num = [13, 14];
    const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."]

    function func(num, str){
        console.log(`${num}. ${str}`); 
    };

    func(num[0], str[0]);
    func(num[1], str[1]);
}
</code></pre>
                    <p class="desc">
                        배열의 인덱스를 사용하여 함수를 여러 번 호출하면 각 호출마다 다른 값을 전달하고, 함수 내에서 템플릿 리터럴을 사용하여 해당 값을 출력할 수 있습니다. 이것은 반복 작업을 효과적으로 처리하거나 다양한 데이터를 함수에 전달하는 방법 중 하나입니다.<br>

                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        const num = [13, 14];
                                        const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."]

                                        function func(num, str){
                                            document.write(`${num}. ${str}`); 
                                        };
                                        func(num[0], str[0]);
                                        document.write("<br>");
                                        func(num[1], str[1]);
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample13 -->

                <div id="sample14" class="sample">
                    <h3>14. 함수 유형 : 함수와 객체 이용한 형태</h3>                        
                    <p>객체를 사용하여 함수를 여러번 호출할 수 있습니다.</p>
<pre><code class="language-js">{
    const info = {
        num: 15,
        str: "함수가 실행되었습니다."
    };
    function func(num, str){
        console.log(`${num}. ${str}`); 
    };
    func(info.num, info.str);
}
</code></pre>
                    <p class="desc">
                        위 예제는 객체 info의 속성 값을 함수의 인자로 전달하여 함수를 호출하고, 함수 내에서는 템플릿 리터럴을 사용하여 해당 값을 출력하는 간단한 예제입니다. 객체를 사용하여 데이터를 더 구조화하고 전달할 수 있어 유용한 패턴 중 하나입니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        const info = {
                                            num: 15,
                                            str: "함수가 실행되었습니다."
                                        };
                                        function func(num, str){
                                            document.write(`${num}. ${str}`); 
                                        };
                                        func(info.num, info.str);
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample14 -->

                <div id="sample15" class="sample">
                    <h3>15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</h3>                        
                    <p>배열 안에 객체를 사용하여 함수를 여러번 호출할 수 있습니다.</p>
<pre><code class="language-js">{
    const info = [
        {num:16, str: "함수가 실행되었습니다."},
        {num:17, str: "함수가 실행되었습니다."}
    ];

    func(info[0].num, info[0].str);
    func(info[1].num, info[1].str);
}
</code></pre>
                    <p class="desc">
                        위에 예제는 배열 안에 있는 객체들을 사용하여 함수를 여러 번 호출하고, 함수 내에서는 해당 객체의 속성 값을 출력하는 예제입니다.<br>
                        이렇게 배열과 객체를 함께 사용하여 데이터를 구조화하고 처리하는 것은 프로그래밍에서 매우 일반적인 패턴입니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        const info = [
                                            {num:16, str: "함수가 실행되었습니다."},
                                            {num:17, str: "함수가 실행되었습니다."}
                                        ];
                                        func(info[0].num, info[0].str);
                                        document.write("<br>");
                                        func(info[1].num, info[1].str);
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample15 -->

                <div id="sample16" class="sample">
                    <h3>16. 함수 유형 : 객체 안에 함수를 이용한 형태</h3>                        
                    <p>객체를 정의하고 그안에 화살표 함수를 이용하여 출력할 수 있습니다.</p>
<pre><code class="language-js">{
    const info = {
        num: 18,
        str: "함수가  실행되었습니다.",
        result: () =&gt; {
            console.log(`${info.num}. ${info.str}`);
        }
    };

    info.result();
}
</code></pre>
                    <p class="desc">
                        객체 내부에서 화살표 함수를 사용하여 콘솔에 메시지를 출력할 수 있습니다.<br>
                        개체 안에 함수는 return false;가 생략이 되어 있습니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        const info = {
                                            num: 18,
                                            str: "함수가  실행되었습니다.",
                                            result: () => {
                                                // return false; 생략되어있음
                                                document.write(`${info.num}. ${info.str}`);
                                            }
                                        };
                                        info.result();
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample16 -->

                <div id="sample17" class="sample">
                    <h3>17. 함수 유형 : 객체 생성자 함수</h3>                        
                    <p>객체 생성자 함수는 JavaScript에서 객체를 생성하기 위한 함수입니다.</p>
<pre><code class="language-js">{
    function Func(num, str){
        this.num  = num;
        this.str = str;
        this. result = () =&gt; {
            console.log(`${this.num}. ${this.str}`);
        };
    };

    // 인스턴스 생성
    const info = new Func(19, "함수가 실행되었습니다.");
    const info2 = new Func(20, "함수가 실행되었습니다.");

    // 호출
    info.result();
    info2.result();
}
</code></pre>
                    <p class="desc">
                        객체 생성자 함수는 내부에서 객체의 초기 상태(속성)을 설정하고 함수 이름은 일반적으로 대문자로 시작하여 객체 생성자 함수임을 나타내며 함수 내에서 this 키워드를 사용하여 객체의 속성을 정의하고 초기화합니다.<br>
                        객체 생성자 함수는 new 연산자와 함께 객체의 인스턴스를 생성하여 생성자 함수에 필요한 인수를 전달하여 초기상태를 설정해야 합니다.<br>
                        객체 인스턴스를 사용하여 해당 객체의 속성을 읽거나 수정하고 메서드를 호출하여 사용합니다.<br>
                        this는 현재 실행 중인 함수 또는 메서드가 속한 객체를 가리킵니다. 원래 화살표 함수에서는 사용할 수 없지만 위에 예제는 객체 안에 선언이 되었기때문에 사용할 수 있습니다.<br>
                        객체 생성자 함수를 사용하면 유사한 구조의 객체를 쉽게 생성하고 초기화할 수 있으며, 이러한 객체들은 생성자 함수의 프로토타입을 공유하여 메서드와 속성을 공유할 수 있습니다. 이러한 패턴은 객체 지향 프로그래밍에서 일반적으로 사용되며, 코드를 보다 모듈화하고 재사용 가능하게 만들어줍니다.<br>
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        function Func(num, str){
                                            this.num  = num;
                                            this.str = str;
                                            this. result = () => {
                                                document.write(`${this.num}. ${this.str}`);
                                            };
                                        };

                                        // 인스턴스 생성
                                        const info = new Func(19, "함수가 실행되었습니다.");
                                        const info2 = new Func(20, "함수가 실행되었습니다.");

                                        // 호출
                                        info.result();
                                        document.write("<br>");
                                        info2.result();
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample17 -->

                <div id="sample18" class="sample">
                    <h3>18. 함수 유형 : 프로토타입 함수</h3>                        
                    <p>프로토타입 함수(Prototype Function)는 JavaScript 객체 지향 프로그래밍에서 중요한 개념 중 하나입니다. 이것은 객체의 프로토타입(prototype)에 정의된 함수를 가리킵니다. 이 함수들은 해당 객체 타입의 모든 인스턴스에서 공유되며, 객체의 메서드로 사용됩니다. 프로토타입 함수를 사용하면 객체의 메서드를 정의할 때 메모리를 효율적으로 사용하고, 코드 재사용을 촉진할 수 있습니다.</p>
<pre><code class="language-js">{
    function Func(num, str){
        this.num = num;
        this.str = str;
    }
    Func.prototype.result = function (){
        console.log(`${this.num}. ${this.str}`);
    };

    const info1 = new Func(21, "함수가 실행되었습니다.");
    const info2 = new Func(22, "함수가 실행되었습니다.");

    info1.result();
    info2.result();
}
</code></pre>
                    <p class="desc">
                        프로토타입 함수는 객체 생성자 함수를 사용하여 정의합니다.<br>
                        생성자 함수의 프로토타입 객체에 메서드를 추가하여 해당 객체 타입의 모든 인스턴스에서 공유합니다. 여기서 중요한 점은 화살표함수를 사용하면 안됩니다. 그 이유는 화살표 함수는 this를 사용할 수 없기때문입니다.<br>
                        생성자 함수를 사용하여 객체의 인스턴스를 생성합니다.<br>
                        프로토타입은 객체의 인스턴스에서 프로토타입 함수를 호출하여 사용합니다.<br>
                        프로토타입은 변수가 전역변수가 아니기 때문에 함수가 많아지면 가독성이 떨어집니다.<br>
                        프로토타입 함수를 사용하면 여러 객체 인스턴스 간에 동일한 동작을 공유하고 코드의 중복을 줄일 수 있으므로, 객체 지향 프로그래밍에서 중요한 개념 중 하나입니다. 이러한 메서드를 프로토타입에 추가하면 모든 객체 인스턴스가 해당 메서드를 공유하게 되므로 메모리 사용량도 절약되고 코드 유지 보수가 용이해집니다
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        function Func(num, str){
                                            this.num = num;
                                            this.str = str;
                                        }
                                        Func.prototype.result = function (){
                                            document.write(`${this.num}. ${this.str}`);
                                        };

                                        const info1 = new Func(21, "함수가 실행되었습니다.");
                                        const info2 = new Func(22, "함수가 실행되었습니다.");

                                        info1.result();
                                        document.write("<br>");
                                        info2.result();
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample18 -->

                <div id="sample19" class="sample">
                    <h3>19. 함수 유형 : 객체 리터럴 함수</h3>                        
                    <p>객체 리터럴(Object Literal)은 JavaScript에서 객체를 생성하는 간단하고 흔히 사용되는 방법 중 하나입니다. 객체 리터럴은 중괄호 {}를 사용하여 객체를 정의하고 초기화합니다. 이것은 객체를 생성하고 속성과 메서드를 할당하는 편리한 방법입니다.</p>
<pre><code class="language-js">{
    function Func(num, str){
        this.num = num;
        this.str = str;
    }

    Func.prototype = {
        result1 : function(){
            console.log(`${this.num}. ${this.str}`);
        },
        result2 : function(){
            console.log(`${this.num}. ${this.str}`);
        }
    };

    const info1 = new Func(23, "함수가 실행되었습니다.");
    const info2 = new Func(24, "함수가 실행되었습니다.");

    info1.result1();
    info2.result2();
}
</code></pre>
                    <p class="desc">
                        객체 리터럴 함수는 {}(중괄호)를 사용하여 객체 생성자 함수를 정의합니다.<br>
                        함수 이름.prototype은 객체를 정의하여 프로토타입에 메서드를 추가하면 해당 함수이름의 객체의 인스턴트에서 이러한 메서드를 공유할 수 있습니다.<br>
                        객체의 인스터를 생성자 함수를 사용하여 생성하여 각 인스턴스의 값을 가집니다.<br>
                        호출하여 각 객체의 메서드를 실행하여 속성값을 사용한 특정 형식의 문자열을 콘솔로 출력합니다.<br>
                        객체 리터럴을 사용하면 코드를 더 간결하게 만들 수 있으며, 필요한 속성과 메서드를 포함하는 객체를 쉽게 정의할 수 있으며 코드 재사용과 유지 보수를 용이하게 하는 데 도움이 됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        function Func(num, str){
                                            this.num = num;
                                            this.str = str;
                                        }

                                        Func.prototype = {
                                            result1 : function(){
                                                document.write(`${this.num}. ${this.str}`);
                                            },
                                            result2 : function(){
                                                document.write(`${this.num}. ${this.str}`);
                                            }
                                        };

                                        const info1 = new Func(23, "함수가 실행되었습니다.");
                                        const info2 = new Func(24, "함수가 실행되었습니다.");

                                        info1.result1();
                                        document.write("<br>");
                                        info2.result2();
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample19 -->

                <div id="sample20" class="sample">
                    <h3>20. 함수 : 즉시실행 함수</h3>                        
                    <p>즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 JavaScript에서 사용되는 함수의 패턴 중 하나입니다. 이 패턴은 함수를 정의하자마자 즉시 호출하는 방식으로 사용됩니다. IIFE는 함수 내의 코드를 캡슐화하고 지역 스코프를 생성하는 데 유용합니다.</p>
<pre><code class="language-js">{
    (function (){
        console.log("25. 함수가 실행되었습니다.")
    })();

    (() => {
        console.log("26. 함수가 실행되었습니다.")
    })();
}</code></pre>
                    <p class="desc">
                        위 예제는 함수가 정의되자마자 ()로 호출됩니다. <br>
                        즉시 실행 함수를 사용하면 함수 내부에서 정의한 변수 및 함수는 외부 스코프와 격리되며, 전역 스코프의 오염을 방지하고 모듈 패턴을 구현하는 데 유용합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        (function (){
                                            document.write("25. 함수가 실행되었습니다.<br>")
                                        })();

                                        (() => {
                                            document.write("26. 함수가 실행되었습니다.")
                                        })();
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample20 -->

                <div id="sample21" class="sample">
                    <h3>21. 함수 : 파라미터 함수</h3>                        
                    <p>파라미터 함수(Parametric Function)란 일반적으로 함수 내부로 전달되는 매개변수(parameter)를 받아 처리하는 함수를 가리킵니다. </p>
<pre><code class="language-js">{
    function func(str = "27. 함수가 실행되었습니다."){
        console.log(str)
    };
    func();

    // 화살표 함수
    const func1 = (str = "28. 함수가 실행되었습니다.") => {
        console.log(str)
    };
    func1();
}</code></pre>
                    <p class="desc">
                        파라미터 함수는 함수가 호출될 때 매개 변수로 값을 전달받아 사용하는 함수입니다.<br>
                        이러한 매개 변수를 사용하여 함수 내부에서 동작을 다양하게 조절할 수 있습니다.<br>
                        위 예제 두개에서의 str은 매개변수이며 기본값으로 func는 27. 함수가 실행되었습니다., func1은 28. 함수가 실행되었습니다. 문자열을 가지고 있습니다.<br>
                        따라서 함수를 호출하게 되면 기본값들이 실행됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        function func(str = "27. 함수가 실행되었습니다.<br>"){
                                            document.write(str)
                                        };
                                        func();

                                        const func1 = (str = "28. 함수가 실행되었습니다.") => {
                                            document.write(str)
                                        };
                                        func1();
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample21 -->

                <div id="sample22" class="sample">
                    <h3>22. 함수 : 재귀 함수</h3>                        
                    <p>재귀 함수(Recursive Function)는 함수 내부에서 자기 자신을 호출하는 것을 말합니다. </p>
<pre><code class="language-js">{
    function func(num){
        for(let i=0; i&lt;num; i++){
            console.log("29. 함수가 실행되었습니다.");
        }
    };
    func(10);

    function func1(num){
        if(num &lt; 1) return;

        console.log("30. 함수가 실행되었습니다.");
        func1(num - 1);
    };
    func1(10);
}</code></pre>
                    <p class="desc">
                        
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        function func(num){
                                            for(let i=0; i<num; i++){
                                                document.write("29. 함수가 실행되었습니다.<br>");
                                            }
                                        };
                                        func(10);

                                        function func1(num){
                                            if(num < 1) return;

                                            document.write("30. 함수가 실행되었습니다.<br>");
                                            func1(num - 1);
                                        };
                                        func1(10);
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample22 -->

                <div id="sample23" class="sample">
                    <h3>23. 함수 : 콜백 함수 : 다른 함수로 실행되는 함수</h3>                        
                    <p></p>
<pre><code class="language-js">{
    // 01 이벤트 콜백 함수
    function func(){
        console.log("31. 함수가 실행되었습니다.")
    };
    btn.addEventListerner("click", func);   // btn을 누르면 click가 작동된 후에 func가 실행된다라는 뜻
    //같은 의미
    btn.addEventListerner("click", () => {
        console.log("31. 함수가 실행되었습니다.")
    });

    // 02 함수를 다른 함수의 인자로 전달 (중요!!, func2가 먼저 실행되고 그 다음에 func1이 실행되게 하는 것)
    function func1(){
        console.log("32. 함수가 실행되었습니다.")
    }
    function func2(callback){
        callback();
        // func1();
    }
    func2(func1);

    // 03 반복문으로 콜백함수 만들기

    function func3(num){
        console.log(num + ". 함수가 실행되었습니다.")
    };

    function func4(callback){
        for(let i=33; i&lt;=38; i++){
            callback(i);
        }
    };
    func4(func3);
}</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                (버튼을 눌렀다는 가정하에 31번은 실행됨)<br>
                                31. 함수가 실행되었습니다.<br>
                                <script>
                                    {
                                        // 02 함수를 다른 함수의 인자로 전달 (이게 중요!!, 이게 func2가 먼저 실행되고 그 다음에 func1이 실행되게 하는 것)
                                        function func1(){
                                            document.write("32. 함수가 실행되었습니다.<br>")
                                        }
                                        function func2(callback){
                                            callback();
                                            // func1();
                                        }
                                        func2(func1);

                                        // 03 반복문으로 콜백함수 만들기

                                        function func3(num){
                                            document.write(num + ". 함수가 실행되었습니다.<br>")
                                        };

                                        function func4(callback){
                                            for(let i=33; i<=38; i++){
                                                callback(i);
                                            }
                                        };
                                        func4(func3);
                                    }
                                </script>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample23 -->

                <div id="sample24" class="sample">
                    <h3>24. 함수 : 비동기 함수 : 콜백 함수</h3>                        
                    <p></p>
<pre><code class="language-js">{
    // 01 동기적인 함수 호출 (39, 40)
    function func1(){
        console.log("39. 함수가 실행되었습니다.");
    }
    function func2(){
        console.log("40. 함수가 실행되었습니다.");
    }

    func1();
    func2();

    // 02 비동기적인 함수 호출 (42, 1초후 41)
    function func3(){
        setTimeout(() => {
            console.log("41. 함수가 실행되었습니다.");
        }, 1000);
    }
    function func4(){
        console.log("42. 함수가 실행되었습니다.");
    }

    func3();
    func4();

    // 03 비동기적인 콜백 함수 호출 (43, 44 (43이 다 다운이된다음에 그다음 44가 호출되게하는 방법 | 가독성이 안 좋아 잘 사용하지 않음))
    {
        function func5(callback){
            setTimeout(() => {
                console.log("43. 함수가 실행되었습니다.");
                callback();
            }, 1000);
        }
        function func6(){
            console.log("44. 함수가 실행되었습니다.");
        }

        func5(function(){
            func6();
        });
    }

    // 콜백 지옥
    {
        function funcA(callback){
            setTimeout(() => {
                console.log("funcA가 실행되었습니다.")
                callback();
            }, 1000)
        };
        function funcB(callback){
            setTimeout(() => {
                console.log("funcB가 실행되었습니다.")
                callback();
            }, 1000)
        };
        function funcC(callback){
            setTimeout(() => {
                console.log("funcC가 실행되었습니다.")
                callback();
            }, 1000)
        };
        function funcD(){
            setTimeout(() => {
                console.log("funcD가 실행되었습니다.")
            }, 1000)
        };

        funcA(function(){
            funcB(function(){
                funcC(function(){
                    funcD();
                });
            });
        });

    }
}</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                39. 함수가 실행되었습니다.<br>
                                40. 함수가 실행되었습니다.<br>
                                42. 함수가 실행되었습니다.<br>
                                41. 함수가 실행되었습니다.<br>
                                43. 함수가 실행되었습니다.<br>
                                44. 함수가 실행되었습니다.<br>
                                funcA가 실행되었습니다.<br>
                                funcB가 실행되었습니다.<br>
                                funcC가 실행되었습니다.<br>
                                funcD가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample24 -->

                <div id="sample25" class="sample">
                    <h3>25. 함수 : 비동기 함수 : 프로미스</h3>                        
                    <p></p>
<pre><code class="language-js">{
    let data = true;

    const func = new Promise((resolve, reject) => {
        if(data){
            resolve("45. 함수가 실행되었습니다.")
        } else {
            reject("45. 함수가 실행되지 않았습니다.")
        }
    });

    func
        .then(
            result => console.log(result)
        )
        .catch (
            error => console.log(error)
        )

    //콜백지옥 --&gt; 프로미스
    function funcA(){
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log("funcA가 실행되었습니다.");
                resolve();
            }, 1000);
        })
    }
    function funcB(){
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log("funcB가 실행되었습니다.");
                resolve();
            }, 1000);
        })
    }
    function funcC(){
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log("funcC가 실행되었습니다.");
                resolve();
            }, 1000);
        })
    }
    function funcD(){
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log("funcD가 실행되었습니다.");
                resolve();
            }, 1000);
        })
    }
    funcA()
        .then(funcB)
        .then(funcC)
        .then(funcD)
        .catch((error) => {
            console.log(error)
        })
}
</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                45. 함수가 실행되었습니다.<br>
                                funcA가 실행되었습니다.<br>
                                funcB가 실행되었습니다.<br>
                                funcC가 실행되었습니다.<br>
                                funcD가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample25 -->

                <div id="sample26" class="sample">
                    <h3>26. 함수 : 비동기 함수 : async/await</h3>                        
                    <p></p>
<pre><code class="language-js">{
    // 01
    function func(){
        console.log("46. 함수가 실행되었습니다.");
    };
    func();

    // 02 : 비동기 방식으로 쓰겠다 선언함
    async function func2(){
        console.log("47. 함수가 실행되었습니다.");
    };
    func2();

    // 03
    async function func3(){
        const result = await fetch("https://l-jy16.github.io/webs2024/json/test.json")
        const data = await result.json();
        console.log(data)
    };
    func3();

    // 04
    async function func4(){
        try{
            const result = await fetch("https://l-jy16.github.io/webs2024/json/test.json")
            const data = await result.json();
            console.log(data)
        } catch (error){
            console.log(error)
        }
    };
    func4();
}</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                <script>
                                    {
                                        // 01
                                        function func(){
                                            document.write("46. 함수가 실행되었습니다.<br>");
                                        };
                                        func();

                                        // 02 : 비동기 방식으로 쓰겠다 선언함
                                        async function func2(){
                                            document.write("47. 함수가 실행되었습니다.<br>");
                                        };
                                        func2();
                                        }
                                </script>
                                0:{subject: '정보처리 기능사', question: '다음 중 디자인의 기본 요소들로 옳은 것은?', incorrect_answers: Array(3), correct_answer: '점, 선, 면, 질감', desc: '디자인의 개념요소,시작요소     / 개념요소 는 점.선.면 / 시각요소 는 형 방향 크기 명암 질감 색체'}<br>
                                1:{subject: '정보처리 기능사', question: '다음 중 시각 디자인의 4대 매체가 아닌 것은?', incorrect_answers: Array(3), correct_answer: '텍스타일 디자인', desc: '4대 매체 : 포스터 디자인, 신문광고, 잡지광고, TV 광고로 이루어져있다.'}<br>
                                2:{subject: '정보처리 기능사', question: '다음과 가장 관계있는 디자인 원리는?', incorrect_answers: Array(3), correct_answer: '강조', desc: '정답은 4번입니다.'}<br>
                                0:{subject: '정보처리 기능사', question: '다음 중 디자인의 기본 요소들로 옳은 것은?', incorrect_answers: Array(3), correct_answer: '점, 선, 면, 질감', desc: '디자인의 개념요소,시작요소     / 개념요소 는 점.선.면 / 시각요소 는 형 방향 크기 명암 질감 색체'}<br>
                                1:{subject: '정보처리 기능사', question: '다음 중 시각 디자인의 4대 매체가 아닌 것은?', incorrect_answers: Array(3), correct_answer: '텍스타일 디자인', desc: '4대 매체 : 포스터 디자인, 신문광고, 잡지광고, TV 광고로 이루어져있다.'}<br>
                                2:{subject: '정보처리 기능사', question: '다음과 가장 관계있는 디자인 원리는?', incorrect_answers: Array(3), correct_answer: '강조', desc: '정답은 4번입니다.'}<br>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample26 -->

                <div id="sample27" class="sample">
                    <h3></h3>                        
                    <p></p>
<pre><code class="language-js">{

}
</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>

                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample27 -->

                <div id="sample28" class="sample">
                    <h3></h3>                        
                    <p></p>
<pre><code class="language-js">{

}
</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>

                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample28 -->

                <div id="sample29" class="sample">
                    <h3></h3>                        
                    <p></p>
<pre><code class="language-js">{

}
</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>

                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample29 -->

                <div id="sample30" class="sample">
                    <h3></h3>                        
                    <p></p>
<pre><code class="language-js">{

}
</code></pre>
                    <p class="desc"></p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>

                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample30 -->

            </div>
            <!-- //main__sample -->

        </main>
        <!-- //main -->


        <footer id="footer">
            <a href="mailto:lee.jiyoung492@gmail.com">lee.jiyoung492@gmail.com</a>
        </footer>
        <!-- //footer -->
    </div>

    <!-- script -->
    <script src="../assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    
    <script>
        // 자바스크립트에서 가장 중요한 것 - 가독성, 재사용성
        // 함수의 특징 1. 실행문 2. 재사용
        
        //01. 함수 : 선언적 함수
        {
            function func(){
                console.log("1. 함수가 실행되었습니다.");
            };
            func();
        }
        //02. 함수 : 익명 함수
        {
            const func = function(){
                console.log("2. 함수가 실행되었습니다.");
            };
            func();
        }
        //03. 함수 : 매개변수 함수
        {
            function func(str){
                console.log(str);
            };
            func("3. 함수가 실행되었습니다.");
        }
        //04. 함수 : 리턴값 함수
        {
            function func(){
                return "4. 함수가 실행되었습니다.";
            };
            console.log(func());
        }
        //05. 함수 : 매개변수 + 리턴값 함수
        {
            function func(str){
                return str;
            };
            console.log(func("5. 함수가 실행되었습니다."));
        }
        //06. 화살표 함수 : 선언적 함수
        {
            func = () => {
                console.log("6.함수가 실행되었습니다.");
            };
            func();
        }
        //07. 화살표 함수 : 익명 함수
        {
            const func = () => {
                console.log("7. 함수가 실행되었습니다.");
            };
            func();
        }
        //08. 화살표 함수 : 매개변수 함수
        {
            func = (str) => {
                console.log(str);
            };
            func("8. 함수가 실행되었습니다.");
        }
        //09. 화살표 함수 : 리턴값 함수
        {
            func = () => {
                return "9. 함수가 실행되었습니다.";
            };
            console.log(func());
        }
        //10. 화살표 함수 : 믹명 함수 + 매개변수 + 리턴값 함수
        {
            const func = (str) => {
                return str;
            };
            console.log(func("10. 함수가 실행되었습니다."));
        }
        //11. 함수 유형 : 함수와 매개변수를 이용한 형태
        {
            function func(num, str){
                console.log(`${num}. ${str}`); 
            };
            func(11, "함수가 실행되었습니다.");
        }
        //12. 함수 유형 : 함수와 변수를 이용한 형태 
        {
            const num = 12;
            const str = "함수가 실행되었습니다.";

            function func(num, str){
                console.log(num + ". " + str);
                console.log(`${num}. ${str}`);  //탬플릿 리터럴을 사용하여 표현한 방식(새로생긴 명령어로 ``안에 그대로 쓰면됨)
            };
            func(num, str);
        }
        //13. 함수 유형 : 함수와 배열 이용한 형태
        {
            const num = [13, 14];
            const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."]

            function func(num, str){
                console.log(`${num}. ${str}`); 
            };
            func(num[0], str[0]);
            func(num[1], str[1]);
        }
        //14. 함수 유형 : 함수와 객체 이용한 형태
        {
            const info = {
                num: 15,
                str: "함수가 실행되었습니다."
            };
            function func(num, str){
                console.log(`${num}. ${str}`); 
            };
            func(info.num, info.str);
        }
        //15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태
        {
            const info = [
                {num:16, str: "함수가 실행되었습니다."},
                {num:17, str: "함수가 실행되었습니다."}
            ];
            func(info[0].num, info[0].str);
            func(info[1].num, info[1].str);
        }
        //16. 함수 유형 : 객체 안에 함수를 이용한 형태 => 변수 안에 함수를 넣어서 출력하는 형태
        {
            const info = {
                num: 18,
                str: "함수가  실행되었습니다.",
                result: () => {
                    // return false; 생략되어있음
                    console.log(`${info.num}. ${info.str}`);
                }
            };
            info.result();
        }
        //17. 함수 유형 : 객체 생성자 함수(가장 중요함 사용빈도가 가장 많음. 11-16 합친 것들)  => 객체 생성자 함수는 꼭 인스턴트 함수를 생성하여 따로 호출을해야합니다.
        // 특징 : 인스턴스 생성 | this - 현재 실행 중인 함수 또는 메서드가 속한 객체를 가리키는것
        // this 함수가 먹히는 이유는 Func에 선언되었기 때문
        // 장점 : 자유롭게 호출 가능 | 단점: 비효율적임
        {
            function Func(num, str){
                this.num  = num;
                this.str = str;
                this. result = () => {
                    console.log(`${this.num}. ${this.str}`);
                };
            };

            // 인스턴스 생성
            const info = new Func(19, "함수가 실행되었습니다.");
            const info2 = new Func(20, "함수가 실행되었습니다.");

            // 호출
            info.result();
            info2.result();

        }
        //18. 함수 유형 : 프로토타입 함수
        // 화살표 함수는 this가 먹히지 않으므로 function을 사용해야한다. 
        // prototype가 있으면 어딘가에 속해있다는 뜻이다.
        // 단점으로 함수가 많아지면 가독성이 떨어진다. 그 이유는 변수가 전역변수가 아니기 때문이다.
        {
            function Func(num, str){
                this.num = num;
                this.str = str;
            }
            Func.prototype.result = function (){
                console.log(`${this.num}. ${this.str}`);
            };

            const info1 = new Func(21, "함수가 실행되었습니다.");
            const info2 = new Func(22, "함수가 실행되었습니다.");

            info1.result();
            info2.result();
        }
        //19. 함수 유형 : 객체 리터럴 함수
        // 함수가 많아지면 가독성이 떨어지기 때문에 {}(리터럴)안에 함수를 선언하여 모아두는 방법이다.
        {
            function Func(num, str){
                this.num = num;
                this.str = str;
            }

            Func.prototype = {
                result1 : function(){
                    console.log(`${this.num}. ${this.str}`);
                },
                result2 : function(){
                    console.log(`${this.num}. ${this.str}`);
                }
            };

            const info1 = new Func(23, "함수가 실행되었습니다.");
            const info2 = new Func(24, "함수가 실행되었습니다.");

            info1.result1();
            info2.result2();
        }

        // 20. 함수 : 즉시실행 함수
        {
            (function (){
                console.log("25. 함수가 실행되었습니다.")
            })();

            (() => {
                console.log("26. 함수가 실행되었습니다.")
            })();
        }

        // 21. 함수 : 파라미터 함수
        {
            function func(str = "27. 함수가 실행되었습니다."){
                console.log(str)
            };
            func();

            const func1 = (str = "28. 함수가 실행되었습니다.") => {
                console.log(str)
            };
            func1();
        }

        // 22. 함수 : 재귀 함수 : 자기 자신을 호출하는 함수
        {
            function func(num){
                for(let i=0; i<num; i++){
                    console.log("29. 함수가 실행되었습니다.");
                }
            };
            func(10);

            function func1(num){
                if(num < 1) return;

                console.log("30. 함수가 실행되었습니다.");
                func1(num - 1);
            };
            func1(10);
        }

        // 23. 함수 : 콜백 함수 : 다른 함수로 실행되는 함수 (중요!!)
        {
            // 01 이벤트 콜백 함수
            // function func(){
            //     console.log("31. 함수가 실행되었습니다.")
            // };
            // btn.addEventListerner("click", func);   // btn을 누르면 click가 작동된 후에 func가 실행된다라는 뜻
            // //같은 의미
            // btn.addEventListerner("click", () => {
            //     console.log("31. 함수가 실행되었습니다.")
            // });

            // 02 함수를 다른 함수의 인자로 전달 (이게 중요!!, 이게 func2가 먼저 실행되고 그 다음에 func1이 실행되게 하는 것)
            function func1(){
                console.log("32. 함수가 실행되었습니다.")
            }
            function func2(callback){
                callback();
                // func1();
            }
            func2(func1);

            // 03 반복문으로 콜백함수 만들기

            function func3(num){
                console.log(num + ". 함수가 실행되었습니다.")
            };

            function func4(callback){
                for(let i=33; i<=38; i++){
                    callback(i);
                }
            };
            func4(func3);
        }

        // 24. 함수 : 비동기 함수 : 콜백 함수
        // {
        //     // 01 동기적인 함수 호출 (39, 40)
        //     function func1(){
        //         console.log("39. 함수가 실행되었습니다.");
        //     }
        //     function func2(){
        //         console.log("40. 함수가 실행되었습니다.");
        //     }

        //     func1();
        //     func2();

        //     // 02 비동기적인 함수 호출 (42, 1초후 41)
        //     function func3(){
        //         setTimeout(() => {
        //             console.log("41. 함수가 실행되었습니다.");
        //         }, 1000);
        //     }
        //     function func4(){
        //         console.log("42. 함수가 실행되었습니다.");
        //     }

        //     func3();
        //     func4();

        //     // 03 비동기적인 콜백 함수 호출 (43, 44 (43이 다 다운이된다음에 그다음 44가 호출되게하는 방법 | 가독성이 안 좋아 잘 사용하지 않음))
        //     {
        //         function func5(callback){
        //             setTimeout(() => {
        //                 console.log("43. 함수가 실행되었습니다.");
        //                 callback();
        //             }, 1000);
        //         }
        //         function func6(){
        //             console.log("44. 함수가 실행되었습니다.");
        //         }

        //         func5(function(){
        //             func6();
        //         });
        //     }

        //     // // 콜백 지옥
        //     {
        //         function funcA(callback){
        //             setTimeout(() => {
        //                 console.log("funcA가 실행되었습니다.")
        //                 callback();
        //             }, 1000)
        //         };
        //         function funcB(callback){
        //             setTimeout(() => {
        //                 console.log("funcB가 실행되었습니다.")
        //                 callback();
        //             }, 1000)
        //         };
        //         function funcC(callback){
        //             setTimeout(() => {
        //                 console.log("funcC가 실행되었습니다.")
        //                 callback();
        //             }, 1000)
        //         };
        //         function funcD(){
        //             setTimeout(() => {
        //                 console.log("funcD가 실행되었습니다.")
        //             }, 1000)
        //         };

        //         funcA(function(){
        //             funcB(function(){
        //                 funcC(function(){
        //                     funcD();
        //                 });
        //             });
        //         });

        //     }
        // }
        
        // 25. 함수 : 비동기 함수 : 프로미스
        // {
        //     let data = true;

        //     const func = new Promise((resolve, reject) => {
        //         if(data){
        //             resolve("45. 함수가 실행되었습니다.")
        //         } else {
        //             reject("45. 함수가 실행되지 않았습니다.")
        //         }
        //     });

        //     func
        //         .then(
        //             result => console.log(result)
        //         )
        //         .catch (
        //             error => console.log(error)
        //         )

        //     //콜백지옥 --> 프로미스
        //     function funcA(){
        //         return new Promise((resolve) => {
        //             setTimeout(() => {
        //                 console.log("funcA가 실행되었습니다.");
        //                 resolve();
        //             }, 1000);
        //         })
        //     }
        //     function funcB(){
        //         return new Promise((resolve) => {
        //             setTimeout(() => {
        //                 console.log("funcB가 실행되었습니다.");
        //                 resolve();
        //             }, 1000);
        //         })
        //     }
        //     function funcC(){
        //         return new Promise((resolve) => {
        //             setTimeout(() => {
        //                 console.log("funcC가 실행되었습니다.");
        //                 resolve();
        //             }, 1000);
        //         })
        //     }
        //     function funcD(){
        //         return new Promise((resolve) => {
        //             setTimeout(() => {
        //                 console.log("funcD가 실행되었습니다.");
        //                 resolve();
        //             }, 1000);
        //         })
        //     }
        //     funcA()
        //         .then(funcB)
        //         .then(funcC)
        //         .then(funcD)
        //         .catch((error) => {
        //             console.log(error)
        //         })
        // }

        // 26. 함수 : 비동기 함수 : async/await
        {
            // 01
            function func(){
                console.log("46. 함수가 실행되었습니다.");
            };
            func();

            // 02 : 비동기 방식으로 쓰겠다 선언함
            async function func2(){
                console.log("47. 함수가 실행되었습니다.");
            };
            func2();

            // 03
            async function func3(){
                const result = await fetch("https://l-jy16.github.io/webs2024/json/gineungsaJC2005_05.json")
                const data = await result.json();
                console.log(data)
            };
            func3();

            // 04
            async function func4(){
                try{
                    const result = await fetch("https://l-jy16.github.io/webs2024/json/gineungsaJC2005_05.json")
                    const data = await result.json();
                    console.log(data)
                } catch (error){
                    console.log(error)
                }
            };
            func4();
        }

        // 27. 함수 : 중첩 함수
        // 28. 함수 : 클로저
        // 29. 클래스 : 기본
        // 30. 클래스 : 상속

    </script>
</body>
</html>